<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, user-scalable=no">
  <meta name="description" content="API docs for the SVD constructor from the Class SVD class from the numdart library, for the Dart programming language.">
  <title>SVD constructor - SVD class - numdart library - Dart API</title>
  <!-- required because all the links are pseudo-absolute -->
  <base href="../..">

  <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500,400i,400,300|Source+Sans+Pro:400,300,700" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="stylesheet" href="static-assets/github.css">
  <link rel="stylesheet" href="static-assets/styles.css">
  <link rel="icon" href="static-assets/favicon.png">
  
</head>

<body>

<div id="overlay-under-drawer"></div>

<header id="title">
  <button id="sidenav-left-toggle" type="button">&nbsp;</button>
  <ol class="breadcrumbs gt-separated dark hidden-xs">
    <li><a href="index.html">scidart</a></li>
    <li><a href="numdart/numdart-library.html">numdart</a></li>
    <li><a href="numdart/SVD-class.html">SVD</a></li>
    <li class="self-crumb">SVD constructor</li>
  </ol>
  <div class="self-name">SVD</div>
  <form class="search navbar-right" role="search">
    <input type="text" id="search-box" autocomplete="off" disabled class="form-control typeahead" placeholder="Loading search...">
  </form>
</header>

<main>

  <div id="dartdoc-sidebar-left" class="col-xs-6 col-sm-3 col-md-2 sidebar sidebar-offcanvas-left">
    <header id="header-search-sidebar" class="hidden-l">
      <form class="search-sidebar" role="search">
        <input type="text" id="search-sidebar" autocomplete="off" disabled class="form-control typeahead" placeholder="Loading search...">
      </form>
    </header>
    
    <ol class="breadcrumbs gt-separated dark hidden-l" id="sidebar-nav">
      <li><a href="index.html">scidart</a></li>
      <li><a href="numdart/numdart-library.html">numdart</a></li>
      <li><a href="numdart/SVD-class.html">SVD</a></li>
      <li class="self-crumb">SVD constructor</li>
    </ol>
    
    <h5>SVD class</h5>
    <ol>
      <li class="section-title"><a href="numdart/SVD-class.html#constructors">Constructors</a></li>
      <li><a href="numdart/SVD/SVD.html">SVD</a></li>
    
      <li class="section-title inherited">
        <a href="numdart/SVD-class.html#instance-properties">Properties</a>
      </li>
      <li class="inherited"><a href="numdart/SVD/hashCode.html">hashCode</a></li>
      <li class="inherited"><a href="numdart/SVD/runtimeType.html">runtimeType</a></li>
    
      <li class="section-title"><a href="numdart/SVD-class.html#instance-methods">Methods</a></li>
      <li><a href="numdart/SVD/cond.html">cond</a></li>
      <li><a href="numdart/SVD/norm2.html">norm2</a></li>
      <li><a href="numdart/SVD/rank.html">rank</a></li>
      <li><a href="numdart/SVD/S.html">S</a></li>
      <li><a href="numdart/SVD/singularValues.html">singularValues</a></li>
      <li><a href="numdart/SVD/U.html">U</a></li>
      <li><a href="numdart/SVD/V.html">V</a></li>
      <li class="inherited"><a href="numdart/SVD/noSuchMethod.html">noSuchMethod</a></li>
      <li class="inherited"><a href="numdart/SVD/toString.html">toString</a></li>
    
      <li class="section-title inherited"><a href="numdart/SVD-class.html#operators">Operators</a></li>
      <li class="inherited"><a href="numdart/SVD/operator_equals.html">operator ==</a></li>
    
    
    
    </ol>
  </div><!--/.sidebar-offcanvas-left-->

  <div id="dartdoc-main-content" class="col-xs-12 col-sm-9 col-md-8 main-content">
      <div><h1><span class="kind-constructor">SVD</span> constructor</h1></div>

    <section class="multi-line-signature">
      
      <span class="name ">SVD</span>(<wbr><span class="parameter" id="-param-Arg"><span class="type-annotation"><a href="numdart/Array2d-class.html">Array2d</a></span> <span class="parameter-name">Arg</span></span>)
    </section>

    <section class="desc markdown">
      <p>Construct the singular value decomposition
 Structure to access U, S and V.
 @param Arg    Rectangular matrix</p>
    </section>
    
    <section class="summary source-code" id="source">
      <h2><span>Implementation</span></h2>
      <pre class="language-dart"><code class="language-dart">SVD(Array2d Arg) {
  &#47;&#47; Derived from LINPACK code.
  &#47;&#47; Initialize.
  Array2d A = Arg.copy();
  _m = Arg.row;
  _n = Arg.column;

  &#47;* Apparently the failing cases are only a proper subset of (m&lt;n),
	 so let&#39;s not throw error.  Correct fix to come later?
    if (m&lt;n) {
	  throw new IllegalArgumentException(&quot;Jama SVD only works for m &gt;= n&quot;); }
    *&#47;
  int nu = math.min(_m, _n);
  _s = Array.fixed(math.min(_m + 1, _n));
  _U = Array2d.fixed(_m, nu, initialValue: 0);
  _V = Array2d.fixed(_n, _n);
  Array e = Array.fixed(_n);
  Array work = Array.fixed(_m);
  bool wantu = true;
  bool wantv = true;

  &#47;&#47; Reduce A to bidiagonal form, storing the diagonal elements
  &#47;&#47; in s and the super-diagonal elements in e.

  int nct = math.min(_m - 1, _n);
  int nrt = math.max(0, math.min(_n - 2, _m));
  for (int k = 0; k &lt; math.max(nct, nrt); k++) {
    if (k &lt; nct) {
      &#47;&#47; Compute the transformation for the k-th column and
      &#47;&#47; place the k-th diagonal in s[k].
      &#47;&#47; Compute 2-norm of k-th column without under&#47;overflow.
      _s[k] = 0;
      for (int i = k; i &lt; _m; i++) {
        _s[k] = hypotenuse(_s[k], A[i][k]);
      }
      if (_s[k] != 0.0) {
        if (A[k][k] &lt; 0.0) {
          _s[k] = -_s[k];
        }
        for (int i = k; i &lt; _m; i++) {
          A[i][k] &#47;= _s[k];
        }
        A[k][k] += 1.0;
      }
      _s[k] = -_s[k];
    }
    for (int j = k + 1; j &lt; _n; j++) {
      if ((k &lt; nct) &amp; (_s[k] != 0.0)) {
        &#47;&#47; Apply the transformation.

        double t = 0;
        for (int i = k; i &lt; _m; i++) {
          t += A[i][k] * A[i][j];
        }
        t = -t &#47; A[k][k];
        for (int i = k; i &lt; _m; i++) {
          A[i][j] += t * A[i][k];
        }
      }

      &#47;&#47; Place the k-th row of A into e for the
      &#47;&#47; subsequent calculation of the row transformation.

      e[j] = A[k][j];
    }
    if (wantu &amp;&amp; (k &lt; nct)) {
      &#47;&#47; Place the transformation in U for subsequent back
      &#47;&#47; multiplication.

      for (int i = k; i &lt; _m; i++) {
        _U[i][k] = A[i][k];
      }
    }
    if (k &lt; nrt) {
      &#47;&#47; Compute the k-th row transformation and place the
      &#47;&#47; k-th super-diagonal in e[k].
      &#47;&#47; Compute 2-norm without under&#47;overflow.
      e[k] = 0;
      for (int i = k + 1; i &lt; _n; i++) {
        e[k] = hypotenuse(e[k], e[i]);
      }
      if (e[k] != 0.0) {
        if (e[k + 1] &lt; 0.0) {
          e[k] = -e[k];
        }
        for (int i = k + 1; i &lt; _n; i++) {
          e[i] &#47;= e[k];
        }
        e[k + 1] += 1.0;
      }
      e[k] = -e[k];
      if ((k + 1 &lt; _m) &amp;&amp; (e[k] != 0.0)) {
        &#47;&#47; Apply the transformation.

        for (int i = k + 1; i &lt; _m; i++) {
          work[i] = 0.0;
        }
        for (int j = k + 1; j &lt; _n; j++) {
          for (int i = k + 1; i &lt; _m; i++) {
            work[i] += e[j] * A[i][j];
          }
        }
        for (int j = k + 1; j &lt; _n; j++) {
          double t = -e[j] &#47; e[k + 1];
          for (int i = k + 1; i &lt; _m; i++) {
            A[i][j] += t * work[i];
          }
        }
      }
      if (wantv) {
        &#47;&#47; Place the transformation in V for subsequent
        &#47;&#47; back multiplication.

        for (int i = k + 1; i &lt; _n; i++) {
          _V[i][k] = e[i];
        }
      }
    }
  }

  &#47;&#47; Set up the final bidiagonal matrix or order p.

  int p = math.min(_n, _m + 1);
  if (nct &lt; _n) {
    _s[nct] = A[nct][nct];
  }
  if (_m &lt; p) {
    _s[p - 1] = 0.0;
  }
  if (nrt + 1 &lt; p) {
    e[nrt] = A[nrt][p - 1];
  }
  e[p - 1] = 0.0;

  &#47;&#47; If required, generate U.

  if (wantu) {
    for (int j = nct; j &lt; nu; j++) {
      for (int i = 0; i &lt; _m; i++) {
        _U[i][j] = 0.0;
      }
      _U[j][j] = 1.0;
    }
    for (int k = nct - 1; k &gt;= 0; k--) {
      if (_s[k] != 0.0) {
        for (int j = k + 1; j &lt; nu; j++) {
          double t = 0;
          for (int i = k; i &lt; _m; i++) {
            t += _U[i][k] * _U[i][j];
          }
          t = -t &#47; _U[k][k];
          for (int i = k; i &lt; _m; i++) {
            _U[i][j] += t * _U[i][k];
          }
        }
        for (int i = k; i &lt; _m; i++) {
          _U[i][k] = -_U[i][k];
        }
        _U[k][k] = 1.0 + _U[k][k];
        for (int i = 0; i &lt; k - 1; i++) {
          _U[i][k] = 0.0;
        }
      } else {
        for (int i = 0; i &lt; _m; i++) {
          _U[i][k] = 0.0;
        }
        _U[k][k] = 1.0;
      }
    }
  }

  &#47;&#47; If required, generate V.

  if (wantv) {
    for (int k = _n - 1; k &gt;= 0; k--) {
      if ((k &lt; nrt) &amp;&amp; (e[k] != 0.0)) {
        for (int j = k + 1; j &lt; nu; j++) {
          double t = 0;
          for (int i = k + 1; i &lt; _n; i++) {
            t += _V[i][k] * _V[i][j];
          }
          t = -t &#47; _V[k + 1][k];
          for (int i = k + 1; i &lt; _n; i++) {
            _V[i][j] += t * _V[i][k];
          }
        }
      }
      for (int i = 0; i &lt; _n; i++) {
        _V[i][k] = 0.0;
      }
      _V[k][k] = 1.0;
    }
  }

  &#47;&#47; Main iteration loop for the singular values.

  int pp = p - 1;
  int iter = 0;
  double eps = math.pow(2.0, -52.0);
  double tiny = math.pow(2.0, -966.0);
  while (p &gt; 0) {
    int k, kase;

    &#47;&#47; Here is where a test for too many iterations would go.

    &#47;&#47; This section of the program inspects for
    &#47;&#47; negligible elements in the s and e arrays.  On
    &#47;&#47; completion the variables kase and k are set as follows.

    &#47;&#47; kase = 1     if s(p) and e[k-1] are negligible and k&lt;p
    &#47;&#47; kase = 2     if s(k) is negligible and k&lt;p
    &#47;&#47; kase = 3     if e[k-1] is negligible, k&lt;p, and
    &#47;&#47;              s(k), ..., s(p) are not negligible (qr step).
    &#47;&#47; kase = 4     if e(p-1) is negligible (convergence).
    for (k = p - 2; k &gt;= -1; k--) {
      if (k == -1) {
        break;
      }
      if (e[k].abs() &lt;= tiny + eps * (_s[k].abs() + _s[k + 1].abs())) {
        e[k] = 0.0;
        break;
      }
    }
    if (k == p - 2) {
      kase = 4;
    } else {
      int ks;
      for (ks = p - 1; ks &gt;= k; ks--) {
        if (ks == k) {
          break;
        }
        double t = (ks != p ? e[ks].abs() : 0.0) +
            (ks != k + 1 ? e[ks - 1].abs() : 0.0);
        if (_s[ks].abs() &lt;= tiny + eps * t) {
          _s[ks] = 0.0;
          break;
        }
      }
      if (ks == k) {
        kase = 3;
      } else if (ks == p - 1) {
        kase = 1;
      } else {
        kase = 2;
        k = ks;
      }
    }
    k++;

    &#47;&#47; Perform the task indicated by kase.

    switch (kase) {
      &#47;&#47; Deflate negligible s(p).

      case 1:
        {
          double f = e[p - 2];
          e[p - 2] = 0.0;
          for (int j = p - 2; j &gt;= k; j--) {
            double t = hypotenuse(_s[j], f);
            double cs = _s[j] &#47; t;
            double sn = f &#47; t;
            _s[j] = t;
            if (j != k) {
              f = -sn * e[j - 1];
              e[j - 1] = cs * e[j - 1];
            }
            if (wantv) {
              for (int i = 0; i &lt; _n; i++) {
                t = cs * _V[i][j] + sn * _V[i][p - 1];
                _V[i][p - 1] = -sn * _V[i][j] + cs * _V[i][p - 1];
                _V[i][j] = t;
              }
            }
          }
        }
        break;

      &#47;&#47; Split at negligible s(k).

      case 2:
        {
          double f = e[k - 1];
          e[k - 1] = 0.0;
          for (int j = k; j &lt; p; j++) {
            double t = hypotenuse(_s[j], f);
            double cs = _s[j] &#47; t;
            double sn = f &#47; t;
            _s[j] = t;
            f = -sn * e[j];
            e[j] = cs * e[j];
            if (wantu) {
              for (int i = 0; i &lt; _m; i++) {
                t = cs * _U[i][j] + sn * _U[i][k - 1];
                _U[i][k - 1] = -sn * _U[i][j] + cs * _U[i][k - 1];
                _U[i][j] = t;
              }
            }
          }
        }
        break;

      &#47;&#47; Perform one qr step.

      case 3:
        {
          &#47;&#47; Calculate the shift.

          double scale = math.max(
              math.max(
                  math.max(math.max(_s[p - 1].abs(), _s[p - 2].abs()),
                      e[p - 2].abs()),
                  _s[k].abs()),
              e[k].abs());
          double sp = _s[p - 1] &#47; scale;
          double spm1 = _s[p - 2] &#47; scale;
          double epm1 = e[p - 2] &#47; scale;
          double sk = _s[k] &#47; scale;
          double ek = e[k] &#47; scale;
          double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) &#47; 2.0;
          double c = (sp * epm1) * (sp * epm1);
          double shift = 0.0;
          if ((b != 0.0) | (c != 0.0)) {
            shift = math.sqrt(b * b + c);
            if (b &lt; 0.0) {
              shift = -shift;
            }
            shift = c &#47; (b + shift);
          }
          double f = (sk + sp) * (sk - sp) + shift;
          double g = sk * ek;

          &#47;&#47; Chase zeros.

          for (int j = k; j &lt; p - 1; j++) {
            double t = hypotenuse(f, g);
            double cs = f &#47; t;
            double sn = g &#47; t;
            if (j != k) {
              e[j - 1] = t;
            }
            f = cs * _s[j] + sn * e[j];
            e[j] = cs * e[j] - sn * _s[j];
            g = sn * _s[j + 1];
            _s[j + 1] = cs * _s[j + 1];
            if (wantv) {
              for (int i = 0; i &lt; _n; i++) {
                t = cs * _V[i][j] + sn * _V[i][j + 1];
                _V[i][j + 1] = -sn * _V[i][j] + cs * _V[i][j + 1];
                _V[i][j] = t;
              }
            }
            t = hypotenuse(f, g);
            cs = f &#47; t;
            sn = g &#47; t;
            _s[j] = t;
            f = cs * e[j] + sn * _s[j + 1];
            _s[j + 1] = -sn * e[j] + cs * _s[j + 1];
            g = sn * e[j + 1];
            e[j + 1] = cs * e[j + 1];
            if (wantu &amp;&amp; (j &lt; _m - 1)) {
              for (int i = 0; i &lt; _m; i++) {
                t = cs * _U[i][j] + sn * _U[i][j + 1];
                _U[i][j + 1] = -sn * _U[i][j] + cs * _U[i][j + 1];
                _U[i][j] = t;
              }
            }
          }
          e[p - 2] = f;
          iter = iter + 1;
        }
        break;

      &#47;&#47; Convergence.
      case 4:
        {
          &#47;&#47; Make the singular values positive.

          if (_s[k] &lt;= 0.0) {
            _s[k] = (_s[k] &lt; 0.0 ? -_s[k] : 0.0);
            if (wantv) {
              for (int i = 0; i &lt;= pp; i++) {
                _V[i][k] = -_V[i][k];
              }
            }
          }

          &#47;&#47; Order the singular values.

          while (k &lt; pp) {
            if (_s[k] &gt;= _s[k + 1]) {
              break;
            }
            double t = _s[k];
            _s[k] = _s[k + 1];
            _s[k + 1] = t;
            if (wantv &amp;&amp; (k &lt; _n - 1)) {
              for (int i = 0; i &lt; _n; i++) {
                t = _V[i][k + 1];
                _V[i][k + 1] = _V[i][k];
                _V[i][k] = t;
              }
            }
            if (wantu &amp;&amp; (k &lt; _m - 1)) {
              for (int i = 0; i &lt; _m; i++) {
                t = _U[i][k + 1];
                _U[i][k + 1] = _U[i][k];
                _U[i][k] = t;
              }
            }
            k++;
          }
          iter = 0;
          p--;
        }
        break;
    }
  }
}</code></pre>
    </section>

  </div> <!-- /.main-content -->

  <div id="dartdoc-sidebar-right" class="col-xs-6 col-sm-6 col-md-2 sidebar sidebar-offcanvas-right">
  </div><!--/.sidebar-offcanvas-->

</main>

<footer>
  <span class="no-break">
    scidart 0.0.1-dev.5
  </span>

  
</footer>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script src="static-assets/typeahead.bundle.min.js"></script>
<script src="static-assets/highlight.pack.js"></script>
<script src="static-assets/URI.js"></script>
<script src="static-assets/script.js"></script>


</body>

</html>
